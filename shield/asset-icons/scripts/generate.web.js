const path = require('path')
const fs = require('fs')
const aliasesNormal = require('./aliases')
const aliasesTransparent = require('./aliases-transparent')
const aliasesNetwork = require('./aliases-network')
const invert = require('./invert')
const getAssetIconPathItems = require('./get-asset-icon-path-items')
const { relativeOutputDir, relativeNodeModulesDir } = require('./common-params')

const POSTFIX_BY_TYPE = {
  transparent: '-transparent',
  network: '-network',
  default: '',
}

const ALIASES_BY_TYPE = {
  transparent: aliasesTransparent,
  network: aliasesNormal,
  default: aliasesNetwork,
}

const FALLBACK_BY_TYPE = {
  network: 'transparent',
}

function mergeAssetData(a, b) {
  if (b.length === 0) return a
  const assetMap = new Map()

  for (const asset of a) {
    const name = asset[0]
    if (!assetMap.has(name)) {
      assetMap.set(name, asset.slice(1))
    }
  }

  for (const asset of b) {
    const name = asset[0]
    if (!assetMap.has(name)) {
      assetMap.set(name, asset.slice(1))
    }
  }

  const result = []
  for (const [key, value] of assetMap.entries()) {
    result.push([key, ...value])
  }

  return result
}

const generate = async ({ type = 'default', legacy = false } = {}) => {
  const postfix = POSTFIX_BY_TYPE[type]
  const outputFileName = `asset-icons${postfix}`

  const aliases = ALIASES_BY_TYPE[type]
  const aliasesInverted = invert(aliases)

  let fallbackItems = []
  let items = await getAssetIconPathItems({ folderPostfix: postfix, legacy })
  const fallBackType = FALLBACK_BY_TYPE[type]
  if (fallBackType) {
    fallbackItems = await getAssetIconPathItems({
      folderPostfix: POSTFIX_BY_TYPE[fallBackType],
      onlyBase: type === 'network',
      legacy,
    })
  }

  items = mergeAssetData(items, fallbackItems)

  try {
    let content = `/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. */`
    content += `\n\n/* eslint-disable camelcase */`
    const references = []

    items
      .sort((a, b) => (a[2] < b[2] ? -1 : a[2] > b[2] ? 1 : 0))
      .forEach(([assetName, d, f]) => {
        const assetNameSvg = `fix_${assetName}`
        references.push(`'${assetName}': ${assetNameSvg}`)

        if (aliasesInverted[assetName]) {
          Object.entries(aliases)
            .filter(([, resolveAssetName]) => resolveAssetName === assetName)
            .forEach(([aliasAssetName]) => {
              references.push(`'${aliasAssetName}': ${assetNameSvg}`)
            })
        }

        const relativeNodeModulesDepth =
          relativeOutputDir.split('/').length - relativeNodeModulesDir.split('/').length + 1
        const pathStart =
          Array.from({ length: relativeNodeModulesDepth }).fill('../').join('') + 'node_modules' // use relative path to implicit `-meta` packages imported by assets-base to avoid disabling eslint @exodus/import/no-extraneous-dependencies

        content = content + '\n' + `import ${assetNameSvg} from '${pathStart}/${d}/${f}'`
      })

    content = content + `\n\nexport default { ${references} }`
    const output = path.resolve(process.cwd(), `${relativeOutputDir}/${outputFileName}.js`)

    fs.existsSync(output) && fs.unlinkSync(output)
    fs.writeFileSync(output, content)
  } catch (e) {
    console.error(e)
  }
}

module.exports = generate
